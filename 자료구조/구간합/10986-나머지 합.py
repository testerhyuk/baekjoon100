"""
핵심 아이디어

"특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다"

구간 합 배열을 이용한 식 S[i] - S[j]는 원본 리스트의 j+1 부터 i까지의 구간 합이다
만약, S[i] % m의 값과 S[j] % m의 값이 같다면
(S[i] - S[j]) % m = 0이 된다

S[i] % m = 0
S[j] % m = 0
S[i] % m - S[j] % m = 0

다시 말해서, m으로 나눈 나머지 값들 중 같은 값을 빼고 다시 m으로 나눈 결과는 m으로 나누어 떨어진다는 말이 된다

말이 어려운데 예를 들면,

리스트 A =  [1, 2, 3, 1, 2]
합 배열 S = [1, 3, 6, 7, 9]
s를 m(m=3)으로 나눈 나머지로 업데이트한 리스트 B = [1, 0, 0, 1, 0]

일 때, 원소가 0인 값은 결국 이미 m으로 나누어 떨어지는 값이기 때문에 0끼리 빼도 결과는 0이다(m으로 나누어 떨어진다)
그렇다면 원소가 1인 값은 처음에 m으로 나누었을 때 나머지가 0이 되지 않는 값(나누어 떨어지지 않는다)인데
1끼리 값을 뺀다면
S[i] % m = 1
S[j] % m = 1
(S[i] - S[j]) % m = 0이 된다

즉, 나머지가 같은 값을 빼야만 m으로 나누어 떨어진다는 의미다.

실제로 적용해보면

S[3] = A[0] + A[1] + A[2] + A[3] = 7
S[0] = A[0] = 1

(S[3] - S[0]) % m = 6 % 3으로 나머지는 0이 되고 3으로 나누어 떨어지는 한 쌍이 된다

따라서 정리하자면

1. 구해놓은 합배열을 m으로 나누어 업데이트
2. 업데이트한 리스트에서 0인 값을 찾아 정답에 더한다
3. 업데이트한 리스트에서 같은 값끼리 빼면 나누어떨어지는 값을 찾을 수 있다
4. 원소가 같은 개수를 구해서 2개를 뽑는 경우의 수를 더해주면 값을 찾을 수 있다
"""

import sys

input = sys.stdin.readline

n, m = map(int, input().split())
lst = list(map(int, input().split()))
psum = [0] * (n+1) # 합 배열 초기화
cnt = 0
tmp = [0] * m # 나머지가 같은 원소 저장하기 위한 리스트

for i in range(1, n+1):
    psum[i] = psum[i-1] + lst[i-1] # 구간 합

for i in range(1, n+1):
    rem = psum[i] % m # 구간 합을 m으로 나눈 값

    if rem == 0:
        cnt += 1
    tmp[rem] += 1 # 나머지가 같은 값 인덱스 증가

for i in range(m):
    if tmp[i] > 1: # 나머지가 같은 값이 있다면
        cnt += (tmp[i] * (tmp[i] - 1) // 2) # n개 중 2개를 뽑는 경우의 수